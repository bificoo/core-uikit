import _extends from '../../@babel/runtime/helpers/esm/extends.js';
import _objectWithoutPropertiesLoose from '../../@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js';
import React__default, { useState, useCallback } from 'react';
import PropTypes from '../../prop-types/index.js';
import cx from 'classnames';
import isNil_1 from '../../lodash/isNil.js';
import Sort from '../../@rsuite/icons/Sort.js';
import SortUp from '../../@rsuite/icons/SortUp.js';
import SortDown from '../../@rsuite/icons/SortDown.js';
import ColumnResizeHandler from './ColumnResizeHandler.js';
import './utils/prefix.js';
import '../../lodash/isPlainObject.js';
import '../../lodash/_baseGetTag.js';
import '../../lodash/_stringToPath.js';
import '../../lodash/_baseToString.js';
import './ColumnGroup.js';
import './utils/translateDOMPositionXY.js';
import '../../dom-lib/esm/requestAnimationFramePolyfill.js';
import '../../dom-lib/esm/cancelAnimationFramePolyfill.js';
import useUpdateEffect from './utils/useUpdateEffect.js';
import useClassNames from './utils/useClassNames.js';
import '../../react-is/index.js';
import '../../lodash/_isFlattenable.js';
import '../../lodash/omit.js';
import '../../lodash/merge.js';
import '../../@juggle/resize-observer/lib/ResizeObserver.js';
import '../../@juggle/resize-observer/lib/algorithms/calculateBoxSize.js';
import '../../lodash/_getTag.js';
import '../../lodash/isArguments.js';
import '../../lodash/isBuffer.js';
import '../../lodash/isTypedArray.js';
import '../../dom-lib/esm/utils/emptyFunction.js';
import '../../dom-lib/esm/utils/normalizeWheel.js';
import Cell from './Cell.js';

var SORTED_ICON = {
  desc: SortDown,
  asc: SortUp
};
var HeaderCell = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
  var className = props.className,
      classPrefix = props.classPrefix,
      width = props.width,
      dataKey = props.dataKey,
      headerHeight = props.headerHeight,
      children = props.children,
      left = props.left,
      sortable = props.sortable,
      sortColumn = props.sortColumn,
      sortType = props.sortType,
      groupHeader = props.groupHeader,
      resizable = props.resizable,
      fixed = props.fixed,
      minWidth = props.minWidth,
      index = props.index,
      flexGrow = props.flexGrow,
      align = props.align,
      verticalAlign = props.verticalAlign,
      onColumnResizeEnd = props.onColumnResizeEnd,
      onResize = props.onResize,
      onColumnResizeStart = props.onColumnResizeStart,
      onColumnResizeMove = props.onColumnResizeMove,
      onSortColumn = props.onSortColumn,
      rest = _objectWithoutPropertiesLoose(props, ["className", "classPrefix", "width", "dataKey", "headerHeight", "children", "left", "sortable", "sortColumn", "sortType", "groupHeader", "resizable", "fixed", "minWidth", "index", "flexGrow", "align", "verticalAlign", "onColumnResizeEnd", "onResize", "onColumnResizeStart", "onColumnResizeMove", "onSortColumn"]);

  var _useState = useState(isNil_1(flexGrow) ? width : 0),
      columnWidth = _useState[0],
      setColumnWidth = _useState[1];

  useUpdateEffect(function () {
    setColumnWidth(isNil_1(flexGrow) ? width : 0);
  }, [flexGrow, width]);

  var _useClassNames = useClassNames(classPrefix),
      withClassPrefix = _useClassNames.withClassPrefix,
      merge = _useClassNames.merge,
      prefix = _useClassNames.prefix;

  var classes = merge(className, withClassPrefix({
    sortable: sortable
  }));
  var ariaSort;

  if (sortColumn === dataKey) {
    ariaSort = 'other';

    if (sortType === 'asc') {
      ariaSort = 'ascending';
    } else if (sortType === 'desc') {
      ariaSort = 'descending';
    }
  }

  var handleClick = useCallback(function () {
    if (sortable) {
      onSortColumn === null || onSortColumn === void 0 ? void 0 : onSortColumn(dataKey);
    }
  }, [dataKey, onSortColumn, sortable]);
  var handleColumnResizeStart = useCallback(function () {
    onColumnResizeStart === null || onColumnResizeStart === void 0 ? void 0 : onColumnResizeStart(columnWidth, left, !!fixed);
  }, [columnWidth, fixed, left, onColumnResizeStart]);
  var handleColumnResizeEnd = useCallback(function (nextColumnWidth, cursorDelta) {
    setColumnWidth(nextColumnWidth);
    onColumnResizeEnd === null || onColumnResizeEnd === void 0 ? void 0 : onColumnResizeEnd(nextColumnWidth, cursorDelta, dataKey, index);
    onResize === null || onResize === void 0 ? void 0 : onResize(nextColumnWidth, dataKey);
  }, [dataKey, index, onColumnResizeEnd, onResize]);

  var renderSortColumn = function renderSortColumn() {
    if (sortable && !groupHeader) {
      var _classNames;

      var SortIcon = sortColumn === dataKey && sortType ? SORTED_ICON[sortType] : Sort;
      var iconClasses = cx(prefix('icon-sort'), (_classNames = {}, _classNames[prefix("icon-sort-" + sortType)] = sortColumn === dataKey, _classNames));
      return /*#__PURE__*/React__default.createElement("span", {
        className: prefix('sort-wrapper')
      }, /*#__PURE__*/React__default.createElement(SortIcon, {
        className: iconClasses
      }));
    }

    return null;
  };

  return /*#__PURE__*/React__default.createElement("div", {
    ref: ref,
    className: classes
  }, /*#__PURE__*/React__default.createElement(Cell, _extends({
    "aria-sort": ariaSort
  }, rest, {
    width: width,
    dataKey: dataKey,
    left: left,
    headerHeight: headerHeight,
    isHeaderCell: true,
    align: !groupHeader ? align : null,
    verticalAlign: !groupHeader ? verticalAlign : null,
    onClick: !groupHeader ? handleClick : null
  }), children, renderSortColumn()), resizable ? /*#__PURE__*/React__default.createElement(ColumnResizeHandler, {
    defaultColumnWidth: columnWidth,
    key: columnWidth,
    columnLeft: left,
    columnFixed: fixed,
    height: headerHeight ? headerHeight - 1 : undefined,
    minWidth: minWidth,
    onColumnResizeMove: onColumnResizeMove,
    onColumnResizeStart: handleColumnResizeStart,
    onColumnResizeEnd: handleColumnResizeEnd
  }) : null);
});
HeaderCell.displayName = 'HeaderCell';
HeaderCell.defaultProps = {
  classPrefix: 'cell-header'
};
HeaderCell.propTypes = {
  index: PropTypes.number,
  sortColumn: PropTypes.string,
  sortType: PropTypes.oneOf(['desc', 'asc']),
  sortable: PropTypes.bool,
  resizable: PropTypes.bool,
  minWidth: PropTypes.number,
  onColumnResizeStart: PropTypes.func,
  onColumnResizeEnd: PropTypes.func,
  onResize: PropTypes.func,
  onColumnResizeMove: PropTypes.func,
  onSortColumn: PropTypes.func,
  flexGrow: PropTypes.number,
  fixed: PropTypes.any,
  children: PropTypes.node
};

export { HeaderCell as default };
